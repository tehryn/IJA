/*
 * Author: Matejka Jiri
 * login:  xmatej52
 * school: VUT FIT
 * date:   6. 5. 2017
 * content: GUI representation one game.
 */
package src.gui;

import src.game.Board;
import src.game.Card;
import src.game.Move;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.TextArea;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JLayeredPane;
import javax.swing.JOptionPane;
import javax.swing.JTextArea;
import javax.swing.border.MatteBorder;


/**
 * Class representing one game.
 * @author Matejka Jiri (xmatej52)
 */
@SuppressWarnings("serial")
public class G_Board extends JLayeredPane {

    /// @var Border around selected card(s)
    private final MatteBorder click_border     = new MatteBorder(2, 2, 2, 2, Color.red);

    /// @var Border around card(s) that can be moved
    private final MatteBorder hint_from_border = new MatteBorder(2, 2, 2, 2, Color.blue);

    /// @var Border around card where card(s) can be move
    private final MatteBorder hint_to_border   = new MatteBorder(2, 2, 2, 2, Color.CYAN);

    /// @var 7 working stacks
    private G_Working_stack[] working_stacks    = new G_Working_stack[7];

    /// @var 4 color stacks
    private G_Single_color_stack[] color_stacks = new G_Single_color_stack[4];

    /// @var visible deck
    private G_Card_deck_visible visible_deck;

    ///@var hidden deck
    private G_Card_deck_hidden  hidden_deck;

    /// @var Tells if move should be done
    private boolean proc_move = false;

    /// @var Tells if borders should be removed (hint was used)
    private boolean was_hint  = false;

    /// @var ID of stack where card(s) is selected
    private int from_id;

    /// @var ID of stack where card(s) will be moved
    private int to_id;

    /// @var Type of stack where card will be moved
    private Stack to_type;

    /// @var Type of stack where card is selected
    private Stack from_type;

    /// @var Card in working stack that was selected
    private Card moved_card;

    /// @var Width of cards
    private int x;

    /// @var Height of cards
    private int y;

    /// @var Shift of cards in working stacks
    private int step;

    /// @var Move that was generated by hint
    private Move hint_move;

    /// @var Game that is displayed
    private Board game = new Board();

    /// @var Score of game
    JTextArea score;

    /**
     * Class representing single stacks (decks).<br>
     * Can hold these values:<br>
     * W - Working stack<br>
     * C - Color stack<br>
     * H - Hidden deck<br>
     * V - Visible deck<br>
     * ERR - Invalid deck
     */
    public static enum Stack {
        W, C, H, V, ERR;
    }

    /**
     * Constructor of game. Constructs and initialize all panels.
     * @param x    Width of cards.
     * @param y    Height of cards.
     * @param step Shift of cards in working stacks.
     */
    public G_Board(int x, int y, int step) {
        this.x = x;
        this.y = y;
        this.step = step;
        setLayout(null);
        setBackground(new Color(0,120,0));
        setOpaque(true);
        visible_deck = new G_Card_deck_visible(x, y);
        hidden_deck  = new G_Card_deck_hidden(x, y);
        hidden_deck.setBounds(10, 10, x, y);
        visible_deck.setBounds(20+x, 10, x, y);
        hidden_deck.addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    clicked_on_hidden();
                }
            });
        visible_deck.addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    clicked_on_visible();
                }
            });
        add(hidden_deck);
        add(visible_deck);
        for (int i = 0; i < 4; i++) {
            color_stacks[i] = new G_Single_color_stack(x, y);
            color_stacks[i].setBounds(40+3*x + i*(10+x), 10, x, y);
            color_stacks[i].addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    clicked_on_color(e);
                }
            });
            add(color_stacks[i]);
        }
        for (int i = 0; i < 7; i++) {
            working_stacks[i] = new G_Working_stack(x, y, step);
            working_stacks[i].setBounds(10 + i*(10+x), y + 20, x, y+step*19);
            working_stacks[i].addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent e) {
                    clicked_on_working(e);
                }
            });
            add(working_stacks[i]);
        }
        setMinimumSize(new Dimension(80 + 7*x, 30+2*y+19*step));
        repaint_all();
    }

    /**
     * Saves game.
     * @param string File where game will be saved.
     */
    public void save_game(String string) {
        game.save_game(string);
    }

    /**
     * Creates new game.
     */
    public void new_game() {
        game.new_game();
        repaint_all();
    }

    /**
     * Loads game from file.
     * @param string File where game is saved.
     */
    public void load_game(String string) {
        game.load_game(string);
        repaint_all();
    }

    /**
     * Undo last move (or moves if used multiple times).
     */
    public void undo() {
        this.game.undo();
        repaint_all();
    }

    /**
     * Display hint for a player.
     */
    public void hint() {
        if (was_hint) {
            unset_hint();
        }
        hint_move = game.help();
        System.out.println(hint_move);
        switch(hint_move.get_type()) {
            case WW:
                working_stacks[hint_move.get_from()].set_border(hint_move.get_card(), hint_from_border);
                working_stacks[hint_move.get_to()].set_border(hint_to_border);
                break;
            case WC:
                working_stacks[hint_move.get_from()].set_border(hint_move.get_card(), hint_from_border);
                color_stacks[hint_move.get_to()].set_border(hint_to_border);
                break;
            case VC:
                visible_deck.set_border(hint_from_border);
                color_stacks[hint_move.get_to()].set_border(hint_to_border);
                break;
            case VW:
                visible_deck.set_border(hint_from_border);
                working_stacks[hint_move.get_to()].set_border(hint_to_border);
                break;
            default: break;
        }
        was_hint = true;
    }

    /**
     * Restarts borders that were set by hint.
     */
    private void unset_hint() {
        switch(hint_move.get_type()) {
            case WW:
                working_stacks[hint_move.get_from()].unset_border(hint_move.get_card());
                working_stacks[hint_move.get_to()].unset_border();
                break;
            case WC:
                working_stacks[hint_move.get_from()].unset_border(hint_move.get_card());
                color_stacks[hint_move.get_to()].unset_border();
                break;
            case VC:
                visible_deck.unset_border();
                color_stacks[hint_move.get_to()].unset_border();
                break;
            case VW:
                visible_deck.unset_border();
                working_stacks[hint_move.get_to()].unset_border();
                break;
            default: break;
        }
	was_hint = false;
    }

    /**
     * Process click on hidden deck.
     * @param e Event created by click.
     */
    private void clicked_on_hidden() {
        if (proc_move) {
            to_type   = Stack.ERR;
            move();
        }
        else {
            from_type = Stack.H;
            move();
        }
    }

    /**
     * Process click on visible deck.
     */
    private void clicked_on_visible() {
        if (proc_move) {
            to_type   = Stack.ERR;
            move();
        }
        else {
            from_type = Stack.V;
            visible_deck.set_border(click_border);
            proc_move = true;
        }
    }

    /**
     * Process click on color stack.
     * @param e Event created by click.
     */
    private void clicked_on_color(MouseEvent e) {
        for (int i = 0; i < 4; i++) {
            if (e.getSource() == color_stacks[i]) {
                if (proc_move) {
                    to_id = i;
                    to_type = Stack.C;
                    move();
                }
                else {
                    from_id = i;
                    from_type = Stack.C;
                    color_stacks[i].set_border(click_border);
                    proc_move = true;
                }
                break;
            }
        }
    }

    /**
     * Process click on working stack.
     * @param e Event created by click.
     */
    private void clicked_on_working(MouseEvent e) {
        for (int i = 0; i < 7; i++) {
            if (e.getSource() == working_stacks[i]) {
                if (proc_move) {
                    to_id = i;
                    to_type = Stack.W;
                    move();
                }
                else {
                    from_id = i;
                    from_type = Stack.W;
                    moved_card = working_stacks[i].get_card(e.getY());
                    if (moved_card.is_error_card() || !moved_card.is_visible()) {
                        return;
                    }
                    working_stacks[i].set_border(moved_card, click_border);
                    proc_move = true;
                }
                break;
            }
        }
    }

    /**
     * Move selected card(s) to selected stack and repaints deck/stack(s).
     */
    private void move() {
	if (was_hint) {
	    unset_hint();
	}
        if (to_type == Stack.ERR) {
            switch(from_type) {
                case H:
                    hidden_deck.unset_border();
                    break;
                case V:
                    visible_deck.unset_border();
                    break;
                case C:
                    color_stacks[from_id].unset_border();
                    break;
                case W:
                    working_stacks[from_id].unset_border(moved_card);
                    break;
                default: break;
            }
        }
        switch (from_type) {
            case H:
                game.fromH_toV();
                repaint_hidden();
                repaint_visible();
                break;
            case V:
                if (to_type == Stack.C) {
                    if (game.fromV_toC(to_id)) {
                        repaint_color(to_id);
                        repaint_visible();
                    }
                    else {
                        visible_deck.unset_border();
                    }
                }
                else if (to_type == Stack.W) {
                    if (game.fromV_toW(to_id)) {
                        repaint_working(to_id);
                        repaint_visible();
                    }
                    else {
                        visible_deck.unset_border();
                    }
                }
                break;
            case C:
                if(to_type == Stack.C) {
                    if (game.fromC_toC(from_id, to_id)) {
                        repaint_color(from_id);
                        repaint_color(to_id);
                    }
                    else {
                        color_stacks[from_id].unset_border();
                    }
                }
                else if (to_type == Stack.W) {
                    if (game.fromC_toW(from_id, to_id)) {
                        repaint_color(from_id);
                        repaint_working(to_id);
                    }
                    else {
                        color_stacks[from_id].unset_border();
                    }
                }
                break;
            case W:
                if(to_type == Stack.C) {
                    if (game.fromW_toC(from_id, to_id)){
                        repaint_working(from_id);
                        repaint_color(to_id);
                    }
                    else {
                        working_stacks[from_id].unset_border(moved_card);
                    }
                }
                else if(to_type == Stack.W) {
                    if (game.fromW_toW(from_id, to_id, moved_card)) {
                        repaint_working(from_id);
                        repaint_working(to_id);
                    }
                    else {
                        working_stacks[from_id].unset_border(moved_card);
                    }
                }
                break;
            default: break;
        }
	repaint_score();
        proc_move = false;
	if (game.is_victory()) {
	    int dialogButton = JOptionPane.YES_NO_OPTION;
	    int dialogResult = JOptionPane.showConfirmDialog (
		    null,
		    "You won the game with score of " + game.get_score() + " points."
		    + "\nDo you wish to continue playing? (If not,\nnew game will be created)"
		    ,"Victory",dialogButton);
	    if(dialogResult == JOptionPane.NO_OPTION){
		new_game();
	    }
	}

    }

    /**
     * Repaints score of game;
     */
    private void repaint_score() {
	if (score != null) {
	    	remove(score);
	}
	score = new JTextArea("Score:\n" + game.get_score());
	score.setBounds(30+2*x, y/2, x, 30);;
	score.setFont(new Font("Serif", Font.CENTER_BASELINE, 11));
	score.setEditable(false);
	add(score);
    }

    /**
     * Reloads data to hidden deck and repaints it.
     */
    private void repaint_hidden() {
        Card c = game.get_hidden_deck(0);
        hidden_deck.clear();
        int j = 0;
        while (!c.is_error_card()) {
            hidden_deck.add_card(c, j++);
            c = game.get_hidden_deck(j);
        }
        hidden_deck.my_repaint();
        repaint();
    }

    /**
     * Reloads data to visible deck and repaints it.
     */
    private void repaint_visible() {
        Card c = game.get_visible_deck(0);
        visible_deck.clear();
        int j = 0;
        while (!c.is_error_card()) {
            visible_deck.add_card(c, j++);
            c = game.get_visible_deck(j);
        }
        visible_deck.my_repaint();
        repaint();
    }

    /**
     * Reloads data to working stack and repaints it.
     * @param i ID of working stack.
     */
    private void repaint_working(int i) {
        Card c = game.get_working_stack(i, 0);
        working_stacks[i].clear();
        int j = 0;
        while (!c.is_error_card()) {
            working_stacks[i].add_card(c, j++);
            c = game.get_working_stack(i, j);
       }
        if (j == 0) {
            working_stacks[i].setBounds(10 + i*(10+x), y + 20, x, y);
        }
        else {
            working_stacks[i].setBounds(10 + i*(10+x), y + 20, x, y+step*19);
        }
        working_stacks[i].my_repaint();
        repaint();
    }

    /**
     * Reloads data to color stack and repaints it.
     * @param i ID of working stack.
     */
    private void repaint_color(int i) {
        color_stacks[i].clear();
        Card c = game.get_color_stack(i, 0);
        int j = 0;
        while (!c.is_error_card()) {
            color_stacks[i].add_card(c, j++);
            c = game.get_color_stack(i, j);
        }
        color_stacks[i].my_repaint();
        repaint();
    }

    /**
     * Reloads all data of all stacks and repaints whole game.
     */
    public void repaint_all() {
        for (int i = 6; i >= 0; i--) {
            repaint_working(i);
        }
        for (int i = 0; i < 4; i++) {
            repaint_color(i);
        }
        repaint_hidden();
        repaint_visible();
	repaint_score();
    }
}